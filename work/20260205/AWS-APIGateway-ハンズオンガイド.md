# Amazon API Gateway ハンズオンガイド

> **対象**: AWS DevOps Professional (DOP-C02) 試験対策
> **前提知識**: AWS基礎、IAM、Lambda、CloudWatch、VPC
> **所要時間**: 約3時間

---

## 目次

1. [API Gateway概要](#1-api-gateway概要)
2. [DOP試験での重要ポイント](#2-dop試験での重要ポイント)
3. [REST API vs HTTP API vs WebSocket API](#3-rest-api-vs-http-api-vs-websocket-api)
4. [ステージとデプロイ](#4-ステージとデプロイ)
5. [スロットリング・キャッシュ](#5-スロットリングキャッシュ)
6. [Lambda統合](#6-lambda統合)
7. [認証・認可](#7-認証認可)
8. [カナリアデプロイ](#8-カナリアデプロイ)
9. [WAF統合](#9-waf統合)
10. [モニタリング](#10-モニタリング)
11. [ハンズオン演習](#11-ハンズオン演習)
12. [DOP試験対策チェックリスト](#12-dop試験対策チェックリスト)

---

## 1. API Gateway概要

### 1.1 API Gatewayとは

```
┌─────────────────────────────────────────────────────────────────────────┐
│                        Amazon API Gateway                               │
│          フルマネージドAPIの作成・公開・管理・監視サービス               │
│                                                                         │
│  ┌────────────────────────────────────────────────────────────────────┐ │
│  │                     APIの種類                                       │ │
│  │                                                                    │ │
│  │  ┌──────────────────┐  ┌──────────────────┐  ┌────────────────┐  │ │
│  │  │   REST API        │  │   HTTP API        │  │ WebSocket API  │  │ │
│  │  │                   │  │                   │  │                │  │ │
│  │  │ ・フル機能        │  │ ・軽量・低コスト  │  │ ・双方向通信   │  │ │
│  │  │ ・APIキー         │  │ ・Lambda/HTTP統合  │  │ ・リアルタイム │  │ │
│  │  │ ・使用量プラン    │  │ ・OIDC/OAuth2     │  │ ・チャット     │  │ │
│  │  │ ・キャッシュ      │  │ ・自動デプロイ    │  │ ・ダッシュボード│ │ │
│  │  │ ・WAF統合         │  │ ・CORS自動設定    │  │ ・IoT          │  │ │
│  │  │ ・リソースポリシー│  │ ・70%低コスト     │  │ ・@connections │  │ │
│  │  │ ・カナリアデプロイ│  │                   │  │   API          │  │ │
│  │  └──────────────────┘  └──────────────────┘  └────────────────┘  │ │
│  └────────────────────────────────────────────────────────────────────┘ │
│                                                                         │
│  ┌────────────────────────────────────────────────────────────────────┐ │
│  │                   統合先 (バックエンド)                              │ │
│  │                                                                    │ │
│  │  ┌────────┐ ┌────────┐ ┌────────┐ ┌────────┐ ┌────────┐         │ │
│  │  │Lambda  │ │ HTTP   │ │ AWS    │ │ VPC    │ │ Mock   │         │ │
│  │  │関数    │ │エンド  │ │サービス│ │ Link   │ │        │         │ │
│  │  │        │ │ポイント│ │(直接)  │ │(NLB/ALB)│ │        │         │ │
│  │  └────────┘ └────────┘ └────────┘ └────────┘ └────────┘         │ │
│  └────────────────────────────────────────────────────────────────────┘ │
│                                                                         │
│  エンドポイントタイプ: エッジ最適化 / リージョン / プライベート         │
└─────────────────────────────────────────────────────────────────────────┘
```

### 1.2 リクエスト処理フロー

```
【API Gatewayリクエスト処理フロー】

クライアント
    │
    ▼
┌─────────────────────────────────────────────────────────────────┐
│                       API Gateway                               │
│                                                                 │
│  1. メソッドリクエスト                                          │
│     ┌──────────────────────────────────────────┐                │
│     │ ・認証/認可 (IAM, Cognito, Lambda Auth)   │                │
│     │ ・リクエストバリデーション                 │                │
│     │ ・APIキー検証                             │                │
│     └──────────────────┬───────────────────────┘                │
│                        ▼                                        │
│  2. 統合リクエスト                                              │
│     ┌──────────────────────────────────────────┐                │
│     │ ・マッピングテンプレート (VTL)             │                │
│     │ ・リクエスト変換                           │                │
│     │ ・バックエンドへの振り分け                 │                │
│     └──────────────────┬───────────────────────┘                │
│                        ▼                                        │
│                   [バックエンド]                                 │
│                   (Lambda/HTTP等)                                │
│                        │                                        │
│                        ▼                                        │
│  3. 統合レスポンス                                              │
│     ┌──────────────────────────────────────────┐                │
│     │ ・レスポンスマッピング                     │                │
│     │ ・ステータスコード変換                     │                │
│     │ ・ヘッダー設定                             │                │
│     └──────────────────┬───────────────────────┘                │
│                        ▼                                        │
│  4. メソッドレスポンス                                          │
│     ┌──────────────────────────────────────────┐                │
│     │ ・レスポンスモデル定義                     │                │
│     │ ・ステータスコード定義                     │                │
│     └──────────────────────────────────────────┘                │
│                                                                 │
│  ※ プロキシ統合の場合、2と3はスキップ（パススルー）             │
└─────────────────────────────────────────────────────────────────┘
    │
    ▼
クライアント（レスポンス受信）
```

---

## 2. DOP試験での重要ポイント

| トピック | 重要度 | 出題パターン |
|---------|--------|-------------|
| **カナリアデプロイ** | ★★★★★ | ステージのカナリア設定、トラフィック分割 |
| **ステージ変数** | ★★★★★ | 環境ごとの設定管理、Lambda エイリアス連携 |
| **スロットリング** | ★★★★★ | アカウント/ステージ/メソッドレベルの制限 |
| **使用量プラン・APIキー** | ★★★★★ | レート制限、クォータ設定、顧客別管理 |
| **Lambda統合方式** | ★★★★★ | プロキシ統合 vs カスタム統合の違い |
| **認証・認可** | ★★★★★ | IAM, Cognito, Lambda Authorizer の使い分け |
| **リソースポリシー** | ★★★★☆ | クロスアカウントアクセス、IPフィルタ |
| **キャッシュ** | ★★★★☆ | TTL、キャッシュ無効化、パーキーキャッシュ |
| **CloudWatchメトリクス** | ★★★★☆ | 4XX/5XXエラー、レイテンシ、カウント |
| **X-Rayトレーシング** | ★★★☆☆ | 分散トレーシングの有効化と分析 |
| **WAF統合** | ★★★☆☆ | Web ACLによるAPI保護 |

---

## 3. REST API vs HTTP API vs WebSocket API

### 3.1 詳細比較表

```
┌─────────────────────┬──────────────────┬──────────────────┬──────────────────┐
│                     │    REST API       │    HTTP API       │  WebSocket API   │
├─────────────────────┼──────────────────┼──────────────────┼──────────────────┤
│ プロトコル          │ REST             │ REST/HTTP        │ WebSocket        │
│ コスト              │ 高い             │ REST比 約70%安い │ 接続時間+メッセ  │
│                     │ $3.50/百万req    │ $1.00/百万req    │ ージ数課金       │
│ レイテンシ          │ 普通             │ 低い             │ 低い(常時接続)   │
├─────────────────────┼──────────────────┼──────────────────┼──────────────────┤
│ Lambda統合          │ プロキシ/カスタム │ プロキシのみ     │ プロキシ/カスタム│
│ HTTPエンドポイント  │ ○               │ ○               │ ×               │
│ AWSサービス直接統合 │ ○               │ ×               │ ○               │
│ VPCリンク           │ ○ (NLB)         │ ○ (ALB/NLB/     │ ×               │
│                     │                  │   Cloud Map)     │                  │
│ Mock統合            │ ○               │ ×               │ ×               │
├─────────────────────┼──────────────────┼──────────────────┼──────────────────┤
│ APIキー             │ ○               │ ×               │ ×               │
│ 使用量プラン        │ ○               │ ×               │ ×               │
│ キャッシュ          │ ○               │ ×               │ ×               │
│ リクエストバリデーション│ ○            │ ○(パラメータ)   │ ×               │
│ マッピングテンプレート│ ○ (VTL)       │ パラメータ       │ ○               │
│                     │                  │ マッピングのみ   │                  │
├─────────────────────┼──────────────────┼──────────────────┼──────────────────┤
│ IAM認証             │ ○               │ ○               │ ○               │
│ Cognito Authorizer  │ ○               │ ×(JWT代替)      │ ×               │
│ Lambda Authorizer   │ ○ (TOKEN/       │ ○               │ ○               │
│                     │  REQUEST)        │ (REQUEST のみ)   │                  │
│ JWT Authorizer      │ × (Cognito経由) │ ○ (ネイティブ)  │ ×               │
│ リソースポリシー    │ ○               │ ×               │ ×               │
├─────────────────────┼──────────────────┼──────────────────┼──────────────────┤
│ WAF統合             │ ○               │ ×               │ ×               │
│ X-Rayトレーシング   │ ○               │ ×               │ ×               │
│ カナリアデプロイ    │ ○               │ ×               │ ×               │
│ カスタムドメイン    │ ○               │ ○               │ ○               │
│ 相互TLS (mTLS)     │ ○               │ ○               │ ×               │
├─────────────────────┼──────────────────┼──────────────────┼──────────────────┤
│ エンドポイントタイプ │ エッジ/          │ リージョン       │ リージョン       │
│                     │ リージョン/       │                  │                  │
│                     │ プライベート      │                  │                  │
│ 自動デプロイ        │ ×               │ ○               │ ×               │
│ デフォルトステージ  │ ×               │ $default         │ ×               │
└─────────────────────┴──────────────────┴──────────────────┴──────────────────┘
```

### 3.2 選択ガイド

```
【API種類の選択フローチャート】

双方向リアルタイム通信が必要？
  │
  ├── Yes → WebSocket API
  │         (チャット, ダッシュボード, IoT)
  │
  └── No → 以下の機能が必要？
            ・APIキー/使用量プラン
            ・キャッシュ
            ・WAF統合
            ・リソースポリシー
            ・カナリアデプロイ
            ・X-Ray
            ・マッピングテンプレート(VTL)
            │
            ├── 1つでもYes → REST API
            │
            └── No → HTTP API (低コスト優先)

DOP試験での注意:
- 「APIキー + 使用量プラン」→ REST API 一択
- 「カナリアデプロイ」→ REST API 一択
- 「WAF統合」→ REST API 一択
- 「JWT認証をネイティブで」→ HTTP API
- 「コスト最適化 + Lambda統合」→ HTTP API
```

### 3.3 エンドポイントタイプ

```
┌──────────────────────────────────────────────────────────────────┐
│                  エンドポイントタイプ                              │
│                                                                  │
│  ┌──────────────────────────────────────┐                       │
│  │ エッジ最適化 (Edge-Optimized)        │                       │
│  │                                      │                       │
│  │  クライアント → CloudFront → API GW  │                       │
│  │                 (自動作成)            │                       │
│  │                                      │                       │
│  │  ・グローバルクライアント向け          │                       │
│  │  ・CloudFrontが自動的に前段に配置     │                       │
│  │  ・デフォルト設定                     │                       │
│  └──────────────────────────────────────┘                       │
│                                                                  │
│  ┌──────────────────────────────────────┐                       │
│  │ リージョン (Regional)                │                       │
│  │                                      │                       │
│  │  クライアント → API GW              │                       │
│  │  (自前CloudFront設定可能)            │                       │
│  │                                      │                       │
│  │  ・同一リージョンのクライアント向け   │                       │
│  │  ・カスタムCloudFront設定が必要な場合 │                       │
│  │  ・EC2/Lambda同一リージョン間通信     │                       │
│  └──────────────────────────────────────┘                       │
│                                                                  │
│  ┌──────────────────────────────────────┐                       │
│  │ プライベート (Private)               │                       │
│  │                                      │                       │
│  │  VPC内 → VPCエンドポイント → API GW │                       │
│  │                                      │                       │
│  │  ・VPC内部からのみアクセス可能        │                       │
│  │  ・リソースポリシーでアクセス制御     │                       │
│  │  ・内部マイクロサービス間通信         │                       │
│  └──────────────────────────────────────┘                       │
└──────────────────────────────────────────────────────────────────┘
```

---

## 4. ステージとデプロイ

### 4.1 デプロイメントモデル

```
【API Gatewayのデプロイメントモデル】

API定義 (リソース/メソッド/統合)
    │
    │  CreateDeployment
    ▼
┌──────────────────────────────────────────────────────────┐
│                    デプロイメント                          │
│                  (API定義のスナップショット)               │
│                                                          │
│  deployment-id: abc123                                   │
│  作成日時: 2026-02-05T10:00:00Z                          │
└──────────────────┬───────────────────────────────────────┘
                   │
        ┌──────────┼──────────┐
        ▼          ▼          ▼
  ┌──────────┐ ┌──────────┐ ┌──────────┐
  │ dev       │ │ staging  │ │ prod     │
  │ ステージ  │ │ ステージ │ │ ステージ │
  │           │ │          │ │          │
  │ URL:      │ │ URL:     │ │ URL:     │
  │ /dev      │ │ /staging │ │ /prod    │
  │           │ │          │ │          │
  │ 変数:     │ │ 変数:    │ │ 変数:    │
  │ lambdaAlias│ │ lambdaAlias│ │ lambdaAlias│
  │ =dev      │ │ =staging │ │ =prod    │
  │           │ │          │ │          │
  │ キャッシュ:│ │ キャッシュ:│ │ キャッシュ:│
  │ OFF       │ │ OFF      │ │ 0.5GB    │
  │           │ │          │ │          │
  │ カナリア: │ │ カナリア:│ │ カナリア:│
  │ なし      │ │ なし     │ │ 10%      │
  └──────────┘ └──────────┘ └──────────┘

呼び出しURL例:
  https://{api-id}.execute-api.{region}.amazonaws.com/{stage}/resource
```

### 4.2 ステージ変数

```
【ステージ変数の活用パターン】

■ パターン1: Lambda関数のエイリアス切り替え

  ステージ変数: lambdaAlias

  devステージ  → lambdaAlias = dev   → my-function:dev
  prodステージ → lambdaAlias = prod  → my-function:prod

  統合リクエストのLambda ARN:
  arn:aws:lambda:region:account:function:my-function:${stageVariables.lambdaAlias}


■ パターン2: HTTPエンドポイントの切り替え

  ステージ変数: backendUrl

  devステージ  → backendUrl = dev-api.example.com
  prodステージ → backendUrl = api.example.com

  統合リクエストのエンドポイント:
  https://${stageVariables.backendUrl}/api


■ パターン3: マッピングテンプレートでの使用

  #set($tableName = $stageVariables.dynamoTable)
  {
    "TableName": "$tableName",
    "Key": { "id": { "S": "$input.params('id')" } }
  }

  devステージ  → dynamoTable = users-dev
  prodステージ → dynamoTable = users-prod
```

**DOP重要ポイント**:
- ステージ変数はLambda ARNのエイリアスと組み合わせて環境分離に使用
- ステージ変数を使うとLambda関数に**リソースベースポリシー**の追加が必要
- `${stageVariables.variableName}` の構文で参照

### 4.3 ステージの設定項目

```
┌─────────────────────────────────────────────────────────┐
│                   ステージ設定                            │
│                                                         │
│  ┌─────────────────────────────────────────────────┐    │
│  │ 基本設定                                         │    │
│  │ ・デプロイメントID (紐付けるデプロイメント)       │    │
│  │ ・説明                                           │    │
│  │ ・キャッシュクラスタサイズ                        │    │
│  │ ・キャッシュ有効/無効                             │    │
│  └─────────────────────────────────────────────────┘    │
│                                                         │
│  ┌─────────────────────────────────────────────────┐    │
│  │ スロットリング設定                               │    │
│  │ ・デフォルトメソッドスロットリング (レート/バースト) │   │
│  │ ・メソッドごとのスロットリング (オーバーライド)   │    │
│  └─────────────────────────────────────────────────┘    │
│                                                         │
│  ┌─────────────────────────────────────────────────┐    │
│  │ ログ/トレーシング                                │    │
│  │ ・CloudWatch Logs (実行ログ)                     │    │
│  │ ・アクセスログ (CLF/JSON/XML/CSV形式)            │    │
│  │ ・X-Rayトレーシング                              │    │
│  │ ・詳細CloudWatchメトリクス                        │    │
│  └─────────────────────────────────────────────────┘    │
│                                                         │
│  ┌─────────────────────────────────────────────────┐    │
│  │ カナリア設定                                     │    │
│  │ ・カナリアトラフィック % (0-100)                  │    │
│  │ ・カナリア用ステージ変数 (オーバーライド)         │    │
│  └─────────────────────────────────────────────────┘    │
│                                                         │
│  ┌─────────────────────────────────────────────────┐    │
│  │ SDK生成                                          │    │
│  │ ・Java, JavaScript, iOS(Swift), Android SDK      │    │
│  └─────────────────────────────────────────────────┘    │
└─────────────────────────────────────────────────────────┘
```

---

## 5. スロットリング・キャッシュ

### 5.1 スロットリングの階層構造

```
【スロットリング制限の階層】

レベル1: AWSアカウント制限 (リージョンごと)
┌─────────────────────────────────────────────────────┐
│ デフォルト: 10,000 リクエスト/秒 (全API合計)        │
│ バースト制限: 5,000 リクエスト                       │
│ ※ 引き上げ可能 (Service Quotasから申請)              │
│ ※ 超過時: 429 Too Many Requests                     │
└─────────────────────────┬───────────────────────────┘
                          │
レベル2: 使用量プラン (Usage Plan)
┌─────────────────────────▼───────────────────────────┐
│ APIキーごとのスロットリング                           │
│ ・レート制限 (リクエスト/秒)                         │
│ ・バースト制限                                       │
│ ・クォータ (日/週/月あたりの総リクエスト数)          │
│ ※ アカウント制限を超えることはできない               │
└─────────────────────────┬───────────────────────────┘
                          │
レベル3: ステージ/メソッドレベル
┌─────────────────────────▼───────────────────────────┐
│ ステージごとのデフォルトスロットリング               │
│ ・デフォルトメソッドレート制限                       │
│ ・デフォルトメソッドバースト制限                     │
│                                                     │
│ 個別メソッドのオーバーライド                         │
│ ・GET /users → 1000 req/sec                         │
│ ・POST /orders → 100 req/sec                        │
│ ※ ステージ設定 > メソッド設定の優先度               │
└─────────────────────────────────────────────────────┘

【トークンバケットアルゴリズム】

  バケット容量 = バースト制限
  トークン補充レート = レート制限 (req/sec)

  リクエスト到着
      │
      ▼
  バケットにトークンがある？
      │
      ├── Yes → リクエスト処理、トークン消費
      │
      └── No → 429 Too Many Requests
```

### 5.2 使用量プラン・APIキー

```
【使用量プラン + APIキーの構成】

┌───────────────────────────────────────────────────────────┐
│                   使用量プラン                              │
│                                                           │
│  ┌─────────────────────┐    ┌─────────────────────┐      │
│  │ Basic Plan           │    │ Premium Plan         │      │
│  │                     │    │                     │      │
│  │ レート: 100 req/sec │    │ レート: 1000 req/sec│      │
│  │ バースト: 200       │    │ バースト: 2000      │      │
│  │ クォータ:           │    │ クォータ:           │      │
│  │   10,000 req/月     │    │   1,000,000 req/月  │      │
│  │                     │    │                     │      │
│  │ 紐付けAPI:          │    │ 紐付けAPI:          │      │
│  │ ・REST API (prod)   │    │ ・REST API (prod)   │      │
│  │                     │    │                     │      │
│  │ APIキー:            │    │ APIキー:            │      │
│  │ ・key-customer-A    │    │ ・key-customer-C    │      │
│  │ ・key-customer-B    │    │ ・key-customer-D    │      │
│  └─────────────────────┘    └─────────────────────┘      │
│                                                           │
│  ※ APIキーは使用量プランに紐付けて使用                    │
│  ※ 1つのAPIキーは1つの使用量プランのみ                   │
│  ※ APIキーは認証目的ではない（スロットリング/クォータ用） │
│  ※ APIキーはx-api-keyヘッダーで送信                      │
└───────────────────────────────────────────────────────────┘
```

**DOP重要ポイント**:
- APIキーは**認証メカニズムではない**（スロットリング制御用）
- 認証にはIAM、Cognito、Lambda Authorizerを使用すること
- 使用量プランにはAPIステージとAPIキーの両方を紐付ける必要がある

### 5.3 APIキャッシュ

```
【API Gatewayキャッシュ】

クライアント
    │
    ▼
┌─────────────────────────────────────────────────────┐
│  API Gateway                                         │
│                                                     │
│  ┌───────────────────────────────────┐              │
│  │         キャッシュ                 │              │
│  │                                   │              │
│  │  キャッシュHIT → 即座にレスポンス │              │
│  │                                   │              │
│  │  キャッシュMISS → バックエンド    │──▶ Lambda    │
│  │                    呼び出し       │              │
│  │                                   │              │
│  │  設定項目:                        │              │
│  │  ・容量: 0.5GB〜237GB             │              │
│  │  ・TTL: 0〜3600秒 (デフォルト300)│              │
│  │  ・暗号化: 有効/無効             │              │
│  │  ・パーキーキャッシュ             │              │
│  └───────────────────────────────────┘              │
│                                                     │
│  キャッシュキー:                                     │
│  ・URLパス                                          │
│  ・クエリ文字列パラメータ (指定時)                   │
│  ・HTTPヘッダー (指定時)                             │
│                                                     │
│  キャッシュ無効化:                                   │
│  ・Cache-Control: max-age=0 ヘッダー                │
│  ・コンソール/APIから手動フラッシュ                  │
│  ・require-authorization-for-cache-control で制御   │
└─────────────────────────────────────────────────────┘

キャッシュコスト: 約 $0.02/時間 (0.5GB) 〜 $4.40/時間 (237GB)

※ キャッシュはREST APIのみ対応（HTTP APIは非対応）
※ ステージ単位で有効化
※ メソッドごとにキャッシュON/OFFをオーバーライド可能
```

**DOP重要ポイント**:
- キャッシュ無効化のデフォルトでは**任意のクライアントが`Cache-Control: max-age=0`で無効化可能**
- `require-authorization-for-cache-control`を有効にしてIAM権限を持つクライアントのみに制限すべき
- パーキーキャッシュ: クエリ文字列やヘッダーをキャッシュキーに含めることで、パラメータごとに異なるレスポンスをキャッシュ

---

## 6. Lambda統合

### 6.1 プロキシ統合 vs カスタム統合

```
【Lambda統合方式の比較】

■ Lambdaプロキシ統合 (AWS_PROXY)
┌─────────────────────────────────────────────────────────┐
│                                                         │
│  クライアント → API Gateway → Lambda                   │
│                 (パススルー)                             │
│                                                         │
│  特徴:                                                  │
│  ・リクエスト全体がeventオブジェクトとしてLambdaに渡る  │
│  ・マッピングテンプレート不要                            │
│  ・レスポンス形式はLambda側で制御                       │
│  ・統合リクエスト/レスポンスの設定不要                   │
│  ・最も簡単で推奨される方式                              │
│                                                         │
│  Lambdaの戻り値形式（必須）:                            │
│  {                                                      │
│    "statusCode": 200,                                   │
│    "headers": { "Content-Type": "application/json" },   │
│    "body": "{\"message\": \"Hello\"}"                   │
│  }                                                      │
│                                                         │
│  ※ bodyは文字列でなければならない                       │
│  ※ isBase64Encoded でバイナリレスポンス対応             │
└─────────────────────────────────────────────────────────┘

■ Lambdaカスタム統合 (AWS)
┌─────────────────────────────────────────────────────────┐
│                                                         │
│  クライアント → API Gateway → Lambda                   │
│                 (変換処理)                               │
│                                                         │
│  リクエスト変換:                                        │
│  ┌─────────────────────────────────────┐               │
│  │ 統合リクエスト マッピングテンプレート │               │
│  │ (VTL: Velocity Template Language)    │               │
│  │                                     │               │
│  │ パラメータの変換/追加/削除           │               │
│  │ ボディの構造変換                     │               │
│  │ ステージ変数の埋め込み               │               │
│  └─────────────────────────────────────┘               │
│                                                         │
│  レスポンス変換:                                        │
│  ┌─────────────────────────────────────┐               │
│  │ 統合レスポンス マッピングテンプレート │               │
│  │                                     │               │
│  │ Lambdaの戻り値を加工                │               │
│  │ ステータスコードの制御               │               │
│  │ レスポンスヘッダーの設定             │               │
│  └─────────────────────────────────────┘               │
│                                                         │
│  ※ 設定は複雑だが柔軟性が高い                          │
│  ※ 既存APIの形式に合わせる場合に有用                    │
│  ※ AWSサービス直接統合でも使用                          │
└─────────────────────────────────────────────────────────┘
```

### 6.2 マッピングテンプレート (VTL)

```
【統合リクエスト マッピングテンプレート例】

■ DynamoDB直接統合（Lambdaなし）

Content-Type: application/json

#set($inputRoot = $input.path('$'))
{
  "TableName": "$stageVariables.tableName",
  "Item": {
    "id": { "S": "$context.requestId" },
    "name": { "S": "$inputRoot.name" },
    "email": { "S": "$inputRoot.email" },
    "createdAt": { "S": "$context.requestTime" }
  }
}

■ 利用可能な変数:
- $input.path('$.field')   → リクエストボディのフィールド
- $input.params('param')   → パス/クエリ/ヘッダーパラメータ
- $context.requestId       → リクエストID
- $context.identity.sourceIp → クライアントIP
- $stageVariables.var      → ステージ変数
- $util.escapeJavaScript() → エスケープユーティリティ
- $util.urlEncode()        → URLエンコード
- $util.base64Encode()     → Base64エンコード
```

### 6.3 Lambdaプロキシ統合のeventオブジェクト

```json
{
  "resource": "/users/{id}",
  "path": "/users/123",
  "httpMethod": "GET",
  "headers": {
    "Accept": "application/json",
    "Authorization": "Bearer xxx"
  },
  "queryStringParameters": {
    "status": "active"
  },
  "pathParameters": {
    "id": "123"
  },
  "stageVariables": {
    "lambdaAlias": "prod"
  },
  "requestContext": {
    "accountId": "123456789012",
    "apiId": "abc123",
    "authorizer": {
      "claims": {},
      "principalId": "user123"
    },
    "httpMethod": "GET",
    "identity": {
      "sourceIp": "203.0.113.1",
      "userAgent": "curl/7.68.0"
    },
    "stage": "prod",
    "requestId": "req-id-xxx",
    "requestTime": "05/Feb/2026:10:00:00 +0000"
  },
  "body": null,
  "isBase64Encoded": false
}
```

---

## 7. 認証・認可

### 7.1 認証方式の比較

```
【API Gateway認証方式の全体像】

┌─────────────────────────────────────────────────────────────────┐
│                   認証・認可メカニズム                            │
│                                                                 │
│  ┌───────────────────────┐  ┌───────────────────────┐          │
│  │  IAM認証              │  │  Cognito Authorizer    │          │
│  │                       │  │  (REST API)            │          │
│  │  SigV4署名で認証      │  │                       │          │
│  │  IAMポリシーで認可    │  │  Cognito User Pool     │          │
│  │                       │  │  のトークンで認証      │          │
│  │  用途:                │  │                       │          │
│  │  ・AWSサービス間通信  │  │  用途:                │          │
│  │  ・IAMユーザー/ロール │  │  ・ユーザー認証       │          │
│  │  ・クロスアカウント   │  │  ・モバイル/Web       │          │
│  │                       │  │  ・ソーシャルログイン │          │
│  └───────────────────────┘  └───────────────────────┘          │
│                                                                 │
│  ┌───────────────────────┐  ┌───────────────────────┐          │
│  │  Lambda Authorizer    │  │  リソースポリシー      │          │
│  │                       │  │                       │          │
│  │  カスタムロジックで   │  │  JSON形式のアクセス   │          │
│  │  認証/認可            │  │  制御ポリシー         │          │
│  │                       │  │                       │          │
│  │  2つのタイプ:         │  │  用途:                │          │
│  │  ・TOKEN型            │  │  ・IP制限             │          │
│  │    (ヘッダーベース)   │  │  ・VPCエンドポイント  │          │
│  │  ・REQUEST型          │  │    制限               │          │
│  │    (ヘッダー+パラメータ)│ │  ・クロスアカウント   │          │
│  │                       │  │    アクセス           │          │
│  │  用途:                │  │                       │          │
│  │  ・サードパーティ認証 │  │  ※ REST APIのみ      │          │
│  │  ・カスタムトークン   │  │                       │          │
│  └───────────────────────┘  └───────────────────────┘          │
└─────────────────────────────────────────────────────────────────┘
```

### 7.2 IAM認証

```
【IAM認証フロー】

クライアント
    │ SigV4署名付きリクエスト
    │ Authorization: AWS4-HMAC-SHA256 ...
    ▼
┌──────────────────────────────────────────┐
│ API Gateway                              │
│                                          │
│ 1. SigV4署名を検証                       │
│ 2. IAMポリシーを評価                     │
│    ・IAMユーザー/ロールのポリシー        │
│    ・API Gatewayリソースポリシー          │
│                                          │
│ IAMポリシーの評価対象:                   │
│ ・execute-api:Invoke                     │
│ ・リソースARN:                           │
│   arn:aws:execute-api:region:account:    │
│   api-id/stage/METHOD/resource           │
└──────────────────────────────────────────┘

IAMポリシー例:
{
  "Effect": "Allow",
  "Action": "execute-api:Invoke",
  "Resource": [
    "arn:aws:execute-api:ap-northeast-1:123456789012:abc123/prod/GET/*",
    "arn:aws:execute-api:ap-northeast-1:123456789012:abc123/prod/POST/orders"
  ]
}
```

### 7.3 Lambda Authorizer

```
【Lambda Authorizer フロー】

■ TOKEN型 (トークンベース)

クライアント
    │ Authorization: Bearer <token>
    ▼
┌──────────────────┐     ┌──────────────────┐
│ API Gateway      │────▶│ Lambda Authorizer │
│                  │     │                   │
│ トークンを       │     │ トークンを検証    │
│ Authorizationヘッダー  │ IAMポリシーを返却 │
│ から抽出         │     │                   │
│                  │◀───│ ポリシードキュメント│
│                  │     └──────────────────┘
│ ポリシーを       │
│ キャッシュ       │
│ (TTL: 0〜3600秒)│
│ デフォルト: 300秒│
└──────┬───────────┘
       ▼
    バックエンド


■ REQUEST型 (リクエストパラメータベース)

クライアント
    │ ヘッダー + クエリ + パス + コンテキスト
    ▼
┌──────────────────┐     ┌──────────────────┐
│ API Gateway      │────▶│ Lambda Authorizer │
│                  │     │                   │
│ 複数のソースから │     │ 複数パラメータで  │
│ IDを抽出         │     │ 認可判断          │
│                  │◀───│ IAMポリシーを返却 │
│                  │     └──────────────────┘
│ パラメータ値を   │
│ キーにキャッシュ │
└──────┬───────────┘
       ▼
    バックエンド


Lambda Authorizerの戻り値:
{
  "principalId": "user123",
  "policyDocument": {
    "Version": "2012-10-17",
    "Statement": [{
      "Action": "execute-api:Invoke",
      "Effect": "Allow",
      "Resource": "arn:aws:execute-api:region:account:api-id/stage/*/resource"
    }]
  },
  "context": {
    "userId": "user123",
    "role": "admin"
  }
}

※ contextフィールドの値は$context.authorizer.keyNameでアクセス可能
```

### 7.4 リソースポリシー

```
【リソースポリシーの活用パターン】

■ IP制限
{
  "Version": "2012-10-17",
  "Statement": [{
    "Effect": "Deny",
    "Principal": "*",
    "Action": "execute-api:Invoke",
    "Resource": "arn:aws:execute-api:region:account:api-id/*",
    "Condition": {
      "NotIpAddress": {
        "aws:SourceIp": ["203.0.113.0/24", "198.51.100.0/24"]
      }
    }
  }]
}

■ クロスアカウントアクセス
{
  "Version": "2012-10-17",
  "Statement": [{
    "Effect": "Allow",
    "Principal": {
      "AWS": "arn:aws:iam::999888777666:role/ExternalRole"
    },
    "Action": "execute-api:Invoke",
    "Resource": "arn:aws:execute-api:region:account:api-id/prod/GET/*"
  }]
}

■ VPCエンドポイント制限（プライベートAPI）
{
  "Version": "2012-10-17",
  "Statement": [{
    "Effect": "Allow",
    "Principal": "*",
    "Action": "execute-api:Invoke",
    "Resource": "arn:aws:execute-api:region:account:api-id/*",
    "Condition": {
      "StringEquals": {
        "aws:sourceVpce": "vpce-0123456789abcdef0"
      }
    }
  }]
}

DOP重要ポイント:
- リソースポリシーはREST APIのみ（HTTP APIは非対応）
- IAM認証 + リソースポリシーの場合、両方の評価結果を組み合わせ
- クロスアカウント: リソースポリシー(Allow) + 呼び出し側IAM(Allow) の両方が必要
- 同一アカウント: リソースポリシーまたはIAMのどちらかでAllow
```

---

## 8. カナリアデプロイ

### 8.1 カナリアリリースデプロイメント

```
【API Gatewayカナリアデプロイの仕組み】

                   prod ステージ
┌──────────────────────────────────────────────────────────┐
│                                                          │
│  ┌──────────────────────┐  ┌──────────────────────┐    │
│  │ 本番デプロイメント    │  │ カナリアデプロイメント│    │
│  │ (deployment-v1)      │  │ (deployment-v2)      │    │
│  │                      │  │                      │    │
│  │ トラフィック: 90%    │  │ トラフィック: 10%    │    │
│  │                      │  │                      │    │
│  │ ステージ変数:        │  │ カナリア変数         │    │
│  │ lambdaAlias=v1       │  │ (オーバーライド):    │    │
│  │                      │  │ lambdaAlias=v2       │    │
│  └──────────────────────┘  └──────────────────────┘    │
│                                                          │
│  同一ステージURL: https://api-id.execute-api.region.     │
│                   amazonaws.com/prod/resource             │
│                                                          │
│  API Gatewayがトラフィックを自動分割                      │
└──────────────────────────────────────────────────────────┘

【カナリアデプロイのライフサイクル】

1. 新デプロイメント作成 (canarySettings付き)
   ┌──────────────┐
   │ prod ステージ │
   │ v1: 100%     │
   └──────┬───────┘
          │ CreateDeployment + canary
          ▼
2. カナリアにトラフィック分割
   ┌──────────────────────┐
   │ prod ステージ         │
   │ v1: 90%  │  v2: 10% │
   │ 本番     │  カナリア │
   └──────────┴──────────┘
          │ メトリクス監視・テスト
          ▼
3a. カナリア昇格 (promote)
   ┌──────────────┐
   │ prod ステージ │
   │ v2: 100%     │  ← カナリアが本番に昇格
   └──────────────┘

3b. カナリア削除 (ロールバック)
   ┌──────────────┐
   │ prod ステージ │
   │ v1: 100%     │  ← カナリアを削除、元に戻る
   └──────────────┘
```

### 8.2 カナリアデプロイとステージ変数

```
【カナリアデプロイ + ステージ変数 + Lambda エイリアス】

                  prod ステージ
┌──────────────────────────────────────────────────────┐
│                                                      │
│  ステージ変数: lambdaAlias = "prod"                  │
│                                                      │
│  カナリア変数オーバーライド: lambdaAlias = "canary"  │
│                                                      │
│  ┌─────────────────────┐ ┌─────────────────────┐   │
│  │ 本番 (90%)           │ │ カナリア (10%)       │   │
│  │                     │ │                     │   │
│  │ → my-func:prod      │ │ → my-func:canary    │   │
│  │   (Lambda v1)       │ │   (Lambda v2)       │   │
│  └─────────────────────┘ └─────────────────────┘   │
└──────────────────────────────────────────────────────┘
                │                    │
                ▼                    ▼
         ┌──────────┐        ┌──────────┐
         │ Lambda   │        │ Lambda   │
         │ my-func  │        │ my-func  │
         │          │        │          │
         │ Alias:   │        │ Alias:   │
         │ prod→v1  │        │ canary→v2│
         └──────────┘        └──────────┘

この構成により:
1. API Gatewayのカナリアでトラフィック分割
2. ステージ変数でLambdaエイリアスを切り替え
3. Lambda側で新旧バージョンを管理
→ 安全なBlue/Greenデプロイメントを実現
```

**DOP重要ポイント**:
- カナリアデプロイはREST APIのみ対応
- カナリアのメトリクスは`stage/canary`として別途記録される
- カナリア昇格 = 新デプロイメントを本番に設定、カナリア設定を削除
- ステージ変数のオーバーライドでカナリアのみ異なるバックエンドを使用可能

---

## 9. WAF統合

### 9.1 API Gateway + WAF

```
【WAF統合アーキテクチャ】

インターネット
    │
    ▼
┌──────────────────────────────────────────┐
│  AWS WAF (Web ACL)                       │
│                                          │
│  ルール評価順序 (優先度順):              │
│                                          │
│  1. IP制限ルール                         │
│     ・特定IPのブロック/許可              │
│     ・レート制限 (IP単位)               │
│                                          │
│  2. SQLインジェクション対策              │
│     ・AWSマネージドルール               │
│                                          │
│  3. XSS対策                              │
│     ・AWSマネージドルール               │
│                                          │
│  4. カスタムルール                        │
│     ・ヘッダー/ボディの検査             │
│     ・地理的制限                         │
│                                          │
│  5. デフォルトアクション (Allow/Block)   │
│                                          │
│  ※ WAFはREST APIのみ対応               │
│  ※ HTTP API, WebSocket APIは非対応      │
└──────────────────┬───────────────────────┘
                   │ 通過
                   ▼
┌──────────────────────────────────────────┐
│  API Gateway (REST API)                  │
│                                          │
│  ステージにWeb ACLを関連付け             │
│                                          │
│  ※ エッジ最適化APIの場合:               │
│    CloudFrontディストリビューション      │
│    にWeb ACLを関連付け                   │
│                                          │
│  ※ リージョナルAPIの場合:               │
│    リージョナルWeb ACLを直接関連付け     │
└──────────────────────────────────────────┘
```

### 9.2 WAFルールの例

```
レートベースルール:
  ・同一IPからの5分間で2000リクエスト超過でブロック
  ・DDoS対策、ブルートフォース防止

地理的制限:
  ・特定国からのアクセスをブロック
  ・コンプライアンス要件への対応

AWSマネージドルールグループ:
  ・AWSManagedRulesCommonRuleSet (一般的な脅威)
  ・AWSManagedRulesSQLiRuleSet (SQLインジェクション)
  ・AWSManagedRulesKnownBadInputsRuleSet (既知の不正入力)
  ・AWSManagedRulesBotControlRuleSet (ボット制御)

DOP重要ポイント:
- API GatewayのIP制限にはリソースポリシーとWAFの2通り
- WAFはリクエストボディの検査も可能（リソースポリシーは不可）
- WAFのレートベースルールでAPIのDDoS保護を強化
- CloudFrontを前段に置く場合、WAFはCloudFrontに関連付け推奨
```

---

## 10. モニタリング

### 10.1 CloudWatchメトリクス

```
【API Gateway CloudWatchメトリクス】

┌─────────────────────────────────────────────────────────────────┐
│                CloudWatch メトリクス                              │
│                                                                 │
│  ■ エラーメトリクス                                             │
│  ┌───────────────────────┬─────────────────────────────────┐   │
│  │ 4XXError              │ クライアントエラー数             │   │
│  │                       │ (400, 401, 403, 404, 429等)      │   │
│  │                       │ スロットリング含む               │   │
│  ├───────────────────────┼─────────────────────────────────┤   │
│  │ 5XXError              │ サーバーエラー数                 │   │
│  │                       │ (500, 502, 503, 504)             │   │
│  │                       │ バックエンド障害を示す           │   │
│  └───────────────────────┴─────────────────────────────────┘   │
│                                                                 │
│  ■ パフォーマンスメトリクス                                     │
│  ┌───────────────────────┬─────────────────────────────────┐   │
│  │ Latency              │ API GW受信〜レスポンス返却の全体 │   │
│  │                       │ 時間 (ミリ秒)                   │   │
│  ├───────────────────────┼─────────────────────────────────┤   │
│  │ IntegrationLatency   │ バックエンド処理時間のみ         │   │
│  │                       │ (ミリ秒)                        │   │
│  │                       │ Latency - IntegrationLatency    │   │
│  │                       │ = API GWオーバーヘッド           │   │
│  └───────────────────────┴─────────────────────────────────┘   │
│                                                                 │
│  ■ ボリュームメトリクス                                         │
│  ┌───────────────────────┬─────────────────────────────────┐   │
│  │ Count                │ APIリクエスト総数                │   │
│  ├───────────────────────┼─────────────────────────────────┤   │
│  │ CacheHitCount        │ キャッシュヒット数               │   │
│  ├───────────────────────┼─────────────────────────────────┤   │
│  │ CacheMissCount       │ キャッシュミス数                 │   │
│  └───────────────────────┴─────────────────────────────────┘   │
│                                                                 │
│  ディメンション:                                                │
│  ・ApiName / Stage / Method / Resource                         │
│  ・詳細メトリクスを有効化するとメソッドレベルで取得可能         │
└─────────────────────────────────────────────────────────────────┘

【推奨アラーム設定】

  5XXError > 0 (1分間)         → バックエンド障害検知
  4XXError > 閾値 (5分間)      → クライアント問題検知
  Latency p99 > 閾値           → パフォーマンス劣化検知
  Count = 0 (5分間)            → APIダウン検知
  IntegrationLatency > 閾値    → バックエンド遅延検知
```

### 10.2 アクセスログ

```
【アクセスログの設定】

API Gateway → CloudWatch Logs (アクセスログ)

  ┌─────────────────────────────────────────────────────┐
  │ アクセスログ設定                                     │
  │                                                     │
  │ 出力先: CloudWatch Logsグループ                     │
  │ 形式: CLF / JSON / XML / CSV (カスタマイズ可能)     │
  │                                                     │
  │ JSON形式の例:                                        │
  │ {                                                   │
  │   "requestId": "$context.requestId",                │
  │   "ip": "$context.identity.sourceIp",               │
  │   "caller": "$context.identity.caller",             │
  │   "user": "$context.identity.user",                 │
  │   "requestTime": "$context.requestTime",            │
  │   "httpMethod": "$context.httpMethod",              │
  │   "resourcePath": "$context.resourcePath",          │
  │   "status": "$context.status",                      │
  │   "protocol": "$context.protocol",                  │
  │   "responseLength": "$context.responseLength",      │
  │   "integrationLatency":                             │
  │     "$context.integrationLatency",                  │
  │   "responseLatency": "$context.responseLatency"     │
  │ }                                                   │
  └─────────────────────────────────────────────────────┘

  ※ 実行ログ（デバッグ用）とアクセスログは別物
  ※ 実行ログ: リクエスト/レスポンスの詳細（開発時のみ推奨）
  ※ アクセスログ: リクエストのサマリ（本番環境で推奨）
  ※ IAMロールにCloudWatch Logs書き込み権限が必要
     (API Gateway全体の設定 → CloudWatch Logsロール ARN)
```

### 10.3 X-Rayトレーシング

```
【X-Rayトレーシング】

クライアント → API Gateway → Lambda → DynamoDB
                    │            │         │
                    ▼            ▼         ▼
              ┌──────────────────────────────────┐
              │           AWS X-Ray               │
              │                                   │
              │  セグメント:                       │
              │  ┌──────────────────────────────┐ │
              │  │ API Gateway (29ms)            │ │
              │  │  └── Lambda (120ms)           │ │
              │  │       └── DynamoDB (15ms)     │ │
              │  └──────────────────────────────┘ │
              │                                   │
              │  サービスマップ:                   │
              │  API GW ──▶ Lambda ──▶ DynamoDB  │
              │                                   │
              │  分析:                             │
              │  ・ボトルネック特定               │
              │  ・エラー箇所の特定               │
              │  ・レイテンシ分布                 │
              └──────────────────────────────────┘

  有効化手順:
  1. ステージ設定でX-Rayトレーシングを有効化
  2. Lambda関数でもX-Rayを有効化
  3. X-Ray SDKをアプリに組み込み (下流サービス追跡)

  ※ REST APIのみ対応（HTTP APIは非対応）
  ※ サンプリングレートの設定可能
  ※ X-Rayトレースヘッダー: X-Amzn-Trace-Id
```

---

## 11. ハンズオン演習

### 演習1: REST API作成とLambda統合

```bash
# 1. Lambda関数用のIAMロール作成
LAMBDA_ROLE_ARN=$(aws iam create-role \
  --role-name dop-apigw-lambda-role \
  --assume-role-policy-document '{
    "Version": "2012-10-17",
    "Statement": [{
      "Effect": "Allow",
      "Principal": {"Service": "lambda.amazonaws.com"},
      "Action": "sts:AssumeRole"
    }]
  }' \
  --query 'Role.Arn' \
  --output text)

aws iam attach-role-policy \
  --role-name dop-apigw-lambda-role \
  --policy-arn arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole

# ロールの伝播待ち
sleep 10

# 2. Lambda関数の作成
cat > /tmp/lambda_function.py << 'PYEOF'
import json
import os

def handler(event, context):
    # プロキシ統合用のレスポンス形式
    stage = event.get('requestContext', {}).get('stage', 'unknown')
    method = event.get('httpMethod', 'unknown')
    path = event.get('path', '/')
    version = os.environ.get('APP_VERSION', 'v1')

    body = {
        "message": "Hello from API Gateway!",
        "stage": stage,
        "method": method,
        "path": path,
        "version": version,
        "queryParams": event.get('queryStringParameters'),
        "pathParams": event.get('pathParameters')
    }

    return {
        "statusCode": 200,
        "headers": {
            "Content-Type": "application/json",
            "X-Custom-Header": "dop-handson"
        },
        "body": json.dumps(body)
    }
PYEOF

cd /tmp && zip -j lambda_function.zip lambda_function.py

LAMBDA_ARN=$(aws lambda create-function \
  --function-name dop-apigw-handler \
  --runtime python3.12 \
  --handler lambda_function.handler \
  --role ${LAMBDA_ROLE_ARN} \
  --zip-file fileb:///tmp/lambda_function.zip \
  --environment 'Variables={APP_VERSION=v1}' \
  --query 'FunctionArn' \
  --output text)

echo "Lambda ARN: ${LAMBDA_ARN}"

# 3. REST APIの作成
API_ID=$(aws apigateway create-rest-api \
  --name "dop-handson-api" \
  --description "DOP-C02 API Gateway Hands-on" \
  --endpoint-configuration types=REGIONAL \
  --query 'id' \
  --output text)

echo "API ID: ${API_ID}"

# 4. ルートリソースIDの取得
ROOT_ID=$(aws apigateway get-resources \
  --rest-api-id ${API_ID} \
  --query 'items[?path==`/`].id' \
  --output text)

# 5. /users リソースの作成
USERS_ID=$(aws apigateway create-resource \
  --rest-api-id ${API_ID} \
  --parent-id ${ROOT_ID} \
  --path-part "users" \
  --query 'id' \
  --output text)

# 6. /users/{id} リソースの作成
USER_ID_RESOURCE=$(aws apigateway create-resource \
  --rest-api-id ${API_ID} \
  --parent-id ${USERS_ID} \
  --path-part "{id}" \
  --query 'id' \
  --output text)

# 7. GET /users メソッドの作成
aws apigateway put-method \
  --rest-api-id ${API_ID} \
  --resource-id ${USERS_ID} \
  --http-method GET \
  --authorization-type NONE \
  --api-key-required false

# 8. Lambda プロキシ統合の設定
ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
REGION=$(aws configure get region)

aws apigateway put-integration \
  --rest-api-id ${API_ID} \
  --resource-id ${USERS_ID} \
  --http-method GET \
  --type AWS_PROXY \
  --integration-http-method POST \
  --uri "arn:aws:apigateway:${REGION}:lambda:path/2015-03-31/functions/${LAMBDA_ARN}/invocations"

# 9. LambdaにAPI Gatewayからの実行権限を付与
aws lambda add-permission \
  --function-name dop-apigw-handler \
  --statement-id apigateway-invoke \
  --action lambda:InvokeFunction \
  --principal apigateway.amazonaws.com \
  --source-arn "arn:aws:execute-api:${REGION}:${ACCOUNT_ID}:${API_ID}/*"

# 10. GET /users/{id} メソッドと統合の設定
aws apigateway put-method \
  --rest-api-id ${API_ID} \
  --resource-id ${USER_ID_RESOURCE} \
  --http-method GET \
  --authorization-type NONE \
  --request-parameters "method.request.path.id=true"

aws apigateway put-integration \
  --rest-api-id ${API_ID} \
  --resource-id ${USER_ID_RESOURCE} \
  --http-method GET \
  --type AWS_PROXY \
  --integration-http-method POST \
  --uri "arn:aws:apigateway:${REGION}:lambda:path/2015-03-31/functions/${LAMBDA_ARN}/invocations"

# 11. devステージへデプロイ
DEPLOYMENT_ID=$(aws apigateway create-deployment \
  --rest-api-id ${API_ID} \
  --stage-name dev \
  --stage-description "Development stage" \
  --description "Initial deployment" \
  --query 'id' \
  --output text)

echo "Deployment ID: ${DEPLOYMENT_ID}"
echo "API URL: https://${API_ID}.execute-api.${REGION}.amazonaws.com/dev"

# 12. APIの呼び出しテスト
curl -s "https://${API_ID}.execute-api.${REGION}.amazonaws.com/dev/users" | python3 -m json.tool
curl -s "https://${API_ID}.execute-api.${REGION}.amazonaws.com/dev/users/123" | python3 -m json.tool
```

### 演習2: ステージ変数とカナリアデプロイ

```bash
# 1. Lambda関数のバージョン発行
VERSION_1=$(aws lambda publish-version \
  --function-name dop-apigw-handler \
  --description "Version 1" \
  --query 'Version' \
  --output text)

echo "Version 1: ${VERSION_1}"

# 2. Lambda エイリアスの作成
aws lambda create-alias \
  --function-name dop-apigw-handler \
  --name prod \
  --function-version ${VERSION_1}

aws lambda create-alias \
  --function-name dop-apigw-handler \
  --name canary \
  --function-version ${VERSION_1}

# 3. エイリアスにAPI Gateway実行権限を付与
aws lambda add-permission \
  --function-name "dop-apigw-handler:prod" \
  --statement-id apigateway-prod \
  --action lambda:InvokeFunction \
  --principal apigateway.amazonaws.com \
  --source-arn "arn:aws:execute-api:${REGION}:${ACCOUNT_ID}:${API_ID}/*"

aws lambda add-permission \
  --function-name "dop-apigw-handler:canary" \
  --statement-id apigateway-canary \
  --action lambda:InvokeFunction \
  --principal apigateway.amazonaws.com \
  --source-arn "arn:aws:execute-api:${REGION}:${ACCOUNT_ID}:${API_ID}/*"

# 4. prodステージの作成（ステージ変数付き）
aws apigateway create-deployment \
  --rest-api-id ${API_ID} \
  --stage-name prod \
  --stage-description "Production stage" \
  --variables 'lambdaAlias=prod'

# 注意: ステージ変数でLambdaエイリアスを使うには
# 統合URIを変更する必要がある（ステージ変数参照）
# 実際の構成では統合URIにステージ変数を含める:
# arn:aws:apigateway:region:lambda:path/.../functions/
#   arn:aws:lambda:region:account:function:dop-apigw-handler:${stageVariables.lambdaAlias}/invocations

# 5. ステージ変数の確認
aws apigateway get-stage \
  --rest-api-id ${API_ID} \
  --stage-name prod \
  --query '{StageName:stageName,Variables:variables,DeploymentId:deploymentId}'

# 6. Lambda関数をv2に更新
aws lambda update-function-configuration \
  --function-name dop-apigw-handler \
  --environment 'Variables={APP_VERSION=v2}'

# 関数更新の完了待ち
aws lambda wait function-updated --function-name dop-apigw-handler

VERSION_2=$(aws lambda publish-version \
  --function-name dop-apigw-handler \
  --description "Version 2" \
  --query 'Version' \
  --output text)

echo "Version 2: ${VERSION_2}"

# 7. canaryエイリアスをv2に更新
aws lambda update-alias \
  --function-name dop-apigw-handler \
  --name canary \
  --function-version ${VERSION_2}

# 8. カナリアデプロイメントの作成
# prodステージにカナリア設定を追加
aws apigateway update-stage \
  --rest-api-id ${API_ID} \
  --stage-name prod \
  --patch-operations \
    'op=replace,path=/canarySettings/percentTraffic,value=10' \
    'op=replace,path=/canarySettings/useStageCache,value=false'

# 9. カナリア設定の確認
aws apigateway get-stage \
  --rest-api-id ${API_ID} \
  --stage-name prod \
  --query '{StageName:stageName,CanarySettings:canarySettings}'

# 10. カナリアの昇格（本番化）
aws apigateway update-stage \
  --rest-api-id ${API_ID} \
  --stage-name prod \
  --patch-operations \
    'op=remove,path=/canarySettings'

echo "カナリアが昇格されました（カナリア設定が削除されました）"

# 11. prodエイリアスもv2に更新
aws lambda update-alias \
  --function-name dop-apigw-handler \
  --name prod \
  --function-version ${VERSION_2}
```

### 演習3: 使用量プランとAPIキー

```bash
# 1. APIキーの必須化（GETメソッドを更新）
aws apigateway update-method \
  --rest-api-id ${API_ID} \
  --resource-id ${USERS_ID} \
  --http-method GET \
  --patch-operations \
    'op=replace,path=/apiKeyRequired,value=true'

# 再デプロイ
aws apigateway create-deployment \
  --rest-api-id ${API_ID} \
  --stage-name prod

# 2. APIキーの作成
API_KEY_ID=$(aws apigateway create-api-key \
  --name "dop-customer-a-key" \
  --description "Customer A API Key" \
  --enabled \
  --query 'id' \
  --output text)

API_KEY_VALUE=$(aws apigateway get-api-key \
  --api-key ${API_KEY_ID} \
  --include-value \
  --query 'value' \
  --output text)

echo "API Key ID: ${API_KEY_ID}"
echo "API Key Value: ${API_KEY_VALUE}"

# 3. 使用量プランの作成 (Basic)
USAGE_PLAN_ID=$(aws apigateway create-usage-plan \
  --name "Basic Plan" \
  --description "Basic tier - 1000 requests/month" \
  --throttle 'burstLimit=20,rateLimit=10' \
  --quota 'limit=1000,offset=0,period=MONTH' \
  --api-stages '[{
    "apiId": "'${API_ID}'",
    "stage": "prod"
  }]' \
  --query 'id' \
  --output text)

echo "Usage Plan ID: ${USAGE_PLAN_ID}"

# 4. APIキーを使用量プランに紐付け
aws apigateway create-usage-plan-key \
  --usage-plan-id ${USAGE_PLAN_ID} \
  --key-id ${API_KEY_ID} \
  --key-type API_KEY

# 5. 使用量プランの確認
aws apigateway get-usage-plan \
  --usage-plan-id ${USAGE_PLAN_ID}

# 6. APIキーなしでの呼び出し（403エラー）
echo "=== APIキーなし ==="
curl -s -o /dev/null -w "%{http_code}" \
  "https://${API_ID}.execute-api.${REGION}.amazonaws.com/prod/users"
echo ""

# 7. APIキー付きでの呼び出し（200成功）
echo "=== APIキーあり ==="
curl -s \
  -H "x-api-key: ${API_KEY_VALUE}" \
  "https://${API_ID}.execute-api.${REGION}.amazonaws.com/prod/users" | python3 -m json.tool

# 8. 使用量の確認
START_DATE=$(date -u +%Y-%m-%d -d "first day of this month")
END_DATE=$(date -u +%Y-%m-%d)

aws apigateway get-usage \
  --usage-plan-id ${USAGE_PLAN_ID} \
  --key-id ${API_KEY_ID} \
  --start-date ${START_DATE} \
  --end-date ${END_DATE}

# 9. Premium使用量プランの作成
PREMIUM_PLAN_ID=$(aws apigateway create-usage-plan \
  --name "Premium Plan" \
  --description "Premium tier - 100000 requests/month" \
  --throttle 'burstLimit=200,rateLimit=100' \
  --quota 'limit=100000,offset=0,period=MONTH' \
  --api-stages '[{
    "apiId": "'${API_ID}'",
    "stage": "prod"
  }]' \
  --query 'id' \
  --output text)

echo "Premium Plan ID: ${PREMIUM_PLAN_ID}"
```

### 演習4: Lambda Authorizer

```bash
# 1. Lambda Authorizer関数の作成
cat > /tmp/authorizer_function.py << 'PYEOF'
import json

def handler(event, context):
    """
    TOKEN型 Lambda Authorizer
    Authorizationヘッダーのトークンを検証
    """
    token = event.get('authorizationToken', '')
    method_arn = event.get('methodArn', '')

    # トークン検証（実際にはJWT検証等を実装）
    if token == 'Bearer allow-token-12345':
        return generate_policy('user123', 'Allow', method_arn)
    elif token == 'Bearer deny-token-99999':
        return generate_policy('user999', 'Deny', method_arn)
    else:
        # 認証失敗 → 401 Unauthorized
        raise Exception('Unauthorized')


def generate_policy(principal_id, effect, method_arn):
    """IAMポリシードキュメントを生成"""
    # method_arn例:
    # arn:aws:execute-api:region:account:api-id/stage/METHOD/resource

    # ワイルドカードでAPIの全メソッドを許可/拒否
    arn_parts = method_arn.split(':')
    api_gateway_arn = ':'.join(arn_parts[:5])
    api_parts = arn_parts[5].split('/')
    resource_arn = f"{api_gateway_arn}:{api_parts[0]}/{api_parts[1]}/*"

    policy = {
        'principalId': principal_id,
        'policyDocument': {
            'Version': '2012-10-17',
            'Statement': [{
                'Action': 'execute-api:Invoke',
                'Effect': effect,
                'Resource': resource_arn
            }]
        },
        'context': {
            'userId': principal_id,
            'scope': 'read write',
            'org': 'example-corp'
        }
    }
    return policy
PYEOF

cd /tmp && zip -j authorizer_function.zip authorizer_function.py

AUTH_LAMBDA_ARN=$(aws lambda create-function \
  --function-name dop-apigw-authorizer \
  --runtime python3.12 \
  --handler authorizer_function.handler \
  --role ${LAMBDA_ROLE_ARN} \
  --zip-file fileb:///tmp/authorizer_function.zip \
  --query 'FunctionArn' \
  --output text)

echo "Authorizer Lambda ARN: ${AUTH_LAMBDA_ARN}"

# 2. Lambda AuthorizerにAPI Gateway実行権限を付与
aws lambda add-permission \
  --function-name dop-apigw-authorizer \
  --statement-id apigateway-auth \
  --action lambda:InvokeFunction \
  --principal apigateway.amazonaws.com \
  --source-arn "arn:aws:execute-api:${REGION}:${ACCOUNT_ID}:${API_ID}/*"

# 3. Authorizerの作成（TOKEN型）
AUTHORIZER_ID=$(aws apigateway create-authorizer \
  --rest-api-id ${API_ID} \
  --name "dop-token-authorizer" \
  --type TOKEN \
  --authorizer-uri "arn:aws:apigateway:${REGION}:lambda:path/2015-03-31/functions/${AUTH_LAMBDA_ARN}/invocations" \
  --identity-source "method.request.header.Authorization" \
  --authorizer-result-ttl-in-seconds 300 \
  --query 'id' \
  --output text)

echo "Authorizer ID: ${AUTHORIZER_ID}"

# 4. /users/{id} のGETメソッドにAuthorizerを設定
aws apigateway update-method \
  --rest-api-id ${API_ID} \
  --resource-id ${USER_ID_RESOURCE} \
  --http-method GET \
  --patch-operations \
    "op=replace,path=/authorizationType,value=CUSTOM" \
    "op=replace,path=/authorizerId,value=${AUTHORIZER_ID}"

# 5. 再デプロイ
aws apigateway create-deployment \
  --rest-api-id ${API_ID} \
  --stage-name dev

# 6. テスト - 認証なし（401）
echo "=== 認証なし ==="
curl -s -o /dev/null -w "%{http_code}" \
  "https://${API_ID}.execute-api.${REGION}.amazonaws.com/dev/users/123"
echo ""

# 7. テスト - 正しいトークン（200）
echo "=== 正しいトークン ==="
curl -s \
  -H "Authorization: Bearer allow-token-12345" \
  "https://${API_ID}.execute-api.${REGION}.amazonaws.com/dev/users/123" | python3 -m json.tool

# 8. テスト - 拒否トークン（403）
echo "=== 拒否トークン ==="
curl -s -o /dev/null -w "%{http_code}" \
  -H "Authorization: Bearer deny-token-99999" \
  "https://${API_ID}.execute-api.${REGION}.amazonaws.com/dev/users/123"
echo ""

# 9. Authorizer一覧の確認
aws apigateway get-authorizers \
  --rest-api-id ${API_ID} \
  --query 'items[].{Name:name,Type:type,TTL:authorizerResultTtlInSeconds}'
```

### 演習5: アクセスログ設定

```bash
# 1. CloudWatch Logs用のIAMロール作成（API Gateway全体設定）
APIGW_CW_ROLE_ARN=$(aws iam create-role \
  --role-name dop-apigw-cloudwatch-role \
  --assume-role-policy-document '{
    "Version": "2012-10-17",
    "Statement": [{
      "Effect": "Allow",
      "Principal": {"Service": "apigateway.amazonaws.com"},
      "Action": "sts:AssumeRole"
    }]
  }' \
  --query 'Role.Arn' \
  --output text)

aws iam attach-role-policy \
  --role-name dop-apigw-cloudwatch-role \
  --policy-arn "arn:aws:iam::aws:policy/service-role/AmazonAPIGatewayPushToCloudWatchLogs"

sleep 10

# 2. API Gatewayアカウント設定（CloudWatch Logsロール）
aws apigateway update-account \
  --patch-operations \
    "op=replace,path=/cloudwatchRoleArn,value=${APIGW_CW_ROLE_ARN}"

# 3. アクセスログ用CloudWatch Logsグループの作成
LOG_GROUP_NAME="/aws/apigateway/dop-handson-api"
aws logs create-log-group --log-group-name "${LOG_GROUP_NAME}"

LOG_GROUP_ARN=$(aws logs describe-log-groups \
  --log-group-name-prefix "${LOG_GROUP_NAME}" \
  --query "logGroups[?logGroupName=='${LOG_GROUP_NAME}'].arn" \
  --output text)

# 4. devステージにアクセスログを設定
ACCESS_LOG_FORMAT='{"requestId":"$context.requestId","ip":"$context.identity.sourceIp","caller":"$context.identity.caller","user":"$context.identity.user","requestTime":"$context.requestTime","httpMethod":"$context.httpMethod","resourcePath":"$context.resourcePath","status":"$context.status","protocol":"$context.protocol","responseLength":"$context.responseLength","integrationLatency":"$context.integrationLatency","responseLatency":"$context.responseLatency","authorizerLatency":"$context.authorizer.latency","errorMessage":"$context.error.message"}'

aws apigateway update-stage \
  --rest-api-id ${API_ID} \
  --stage-name dev \
  --patch-operations \
    "op=replace,path=/accessLogSettings/destinationArn,value=${LOG_GROUP_ARN}" \
    "op=replace,path=/accessLogSettings/format,value=${ACCESS_LOG_FORMAT}"

# 5. 実行ログの有効化（デバッグ用）
aws apigateway update-stage \
  --rest-api-id ${API_ID} \
  --stage-name dev \
  --patch-operations \
    'op=replace,path/*/*/logging/loglevel,value=INFO' \
    'op=replace,path/*/*/logging/dataTrace,value=true'

# 6. 詳細メトリクスの有効化
aws apigateway update-stage \
  --rest-api-id ${API_ID} \
  --stage-name dev \
  --patch-operations \
    'op=replace,path/*/*/metrics/enabled,value=true'

# 7. ステージ設定の確認
aws apigateway get-stage \
  --rest-api-id ${API_ID} \
  --stage-name dev \
  --query '{AccessLogSettings:accessLogSettings,MethodSettings:methodSettings}'

# 8. APIを数回呼び出してログを生成
for i in {1..5}; do
  curl -s "https://${API_ID}.execute-api.${REGION}.amazonaws.com/dev/users" > /dev/null
  sleep 1
done

# 9. アクセスログの確認
sleep 10
aws logs filter-log-events \
  --log-group-name "${LOG_GROUP_NAME}" \
  --limit 5 \
  --query 'events[].message'

# 10. X-Rayトレーシングの有効化
aws apigateway update-stage \
  --rest-api-id ${API_ID} \
  --stage-name dev \
  --patch-operations \
    'op=replace,path=/tracingEnabled,value=true'

echo "X-Rayトレーシングが有効化されました"
```

### 演習6: クリーンアップ

```bash
# 1. API Gatewayの削除
aws apigateway delete-rest-api \
  --rest-api-id ${API_ID}

echo "REST API deleted"

# 2. Lambda関数の削除
aws lambda delete-function --function-name dop-apigw-handler
aws lambda delete-function --function-name dop-apigw-authorizer

echo "Lambda functions deleted"

# 3. IAMロールの削除
aws iam detach-role-policy \
  --role-name dop-apigw-lambda-role \
  --policy-arn arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
aws iam delete-role --role-name dop-apigw-lambda-role

aws iam detach-role-policy \
  --role-name dop-apigw-cloudwatch-role \
  --policy-arn "arn:aws:iam::aws:policy/service-role/AmazonAPIGatewayPushToCloudWatchLogs"
aws iam delete-role --role-name dop-apigw-cloudwatch-role

echo "IAM roles deleted"

# 4. CloudWatch Logsグループの削除
aws logs delete-log-group \
  --log-group-name "/aws/apigateway/dop-handson-api"

echo "Log group deleted"

# 5. 使用量プランの削除
# (変数が残っている場合)
# aws apigateway delete-usage-plan --usage-plan-id ${USAGE_PLAN_ID}
# aws apigateway delete-usage-plan --usage-plan-id ${PREMIUM_PLAN_ID}

# 6. APIキーの削除
# aws apigateway delete-api-key --api-key ${API_KEY_ID}

echo "=== クリーンアップ完了 ==="
```

---

## 12. DOP試験対策チェックリスト

### Q1: カナリアデプロイ
**Q: API Gatewayで新バージョンのAPIを安全にリリースするためのカナリアデプロイの仕組みを説明してください。ロールバック方法も含めて。**

<details><summary>模範解答</summary>

API Gatewayのカナリアデプロイでは、同一ステージ内で本番デプロイメントとカナリアデプロイメントにトラフィックを分割する。カナリア設定でpercentTrafficを指定（例: 10%）し、新デプロイメントをカナリアとして配置する。カナリア用のステージ変数オーバーライドで異なるLambdaエイリアスを指定可能。CloudWatchメトリクスでカナリアの4XX/5XXエラー率やレイテンシを監視し、問題なければカナリアを昇格（promote）して100%トラフィックに切り替える。問題があればカナリア設定を削除してロールバック。REST APIのみ対応。

</details>

### Q2: ステージ変数
**Q: API Gatewayのステージ変数を使って、開発/本番環境で異なるLambda関数を呼び出す方法を説明してください。**

<details><summary>模範解答</summary>

統合リクエストのLambda ARNにステージ変数を含める（例: `arn:aws:lambda:region:account:function:my-func:${stageVariables.lambdaAlias}`）。devステージでは`lambdaAlias=dev`、prodステージでは`lambdaAlias=prod`を設定し、Lambda側でdev/prodエイリアスを作成して対応するバージョンを指す。ステージ変数でLambdaエイリアスを参照する場合、各エイリアスに対してLambdaのリソースベースポリシーで`lambda:InvokeFunction`権限をAPI Gatewayに付与する必要がある。DynamoDBテーブル名やHTTPエンドポイントURLの切り替えにも利用可能。

</details>

### Q3: スロットリング
**Q: API Gatewayのスロットリング制限の階層構造と、429エラーが発生した場合の対処法を説明してください。**

<details><summary>模範解答</summary>

スロットリングは3階層で制御される。(1) AWSアカウントレベル: リージョンごとにデフォルト10,000 req/sec、バースト5,000（全API合計、Service Quotasで引き上げ可能）。(2) 使用量プランレベル: APIキーごとのレート/バースト/クォータ（日/週/月）。(3) ステージ/メソッドレベル: ステージのデフォルトスロットリングとメソッド単位のオーバーライド。429エラー対処: クライアント側でExponential Backoffリトライ実装、使用量プランの制限引き上げ、アカウントレベル制限のService Quotas申請、キャッシュの有効化でバックエンド呼び出し削減。

</details>

### Q4: 使用量プランとAPIキー
**Q: APIの外部顧客に対して異なるレベルのアクセスを提供するにはどうすればよいですか？APIキーは認証に使えますか？**

<details><summary>模範解答</summary>

使用量プランを顧客ティアごとに作成する（例: Basic=100 req/sec、Premium=1000 req/sec）。各プランにレート制限、バースト制限、月間クォータを設定し、APIステージを紐付ける。顧客ごとにAPIキーを発行し、対応する使用量プランに紐付ける。重要: APIキーは認証メカニズムではなく、スロットリングとクォータ制御が目的。認証にはIAM認証、Cognito Authorizer、またはLambda Authorizerを別途使用する必要がある。APIキーはx-api-keyヘッダーで送信し、メソッドレベルでapiKeyRequired=trueに設定する。

</details>

### Q5: Lambda統合方式
**Q: API GatewayのLambdaプロキシ統合とカスタム統合の違い、使い分けを説明してください。**

<details><summary>模範解答</summary>

Lambdaプロキシ統合（AWS_PROXY）: リクエスト全体をeventオブジェクトとしてLambdaに渡し、LambdaがstatusCode/headers/bodyを含む所定の形式でレスポンスを返す。マッピングテンプレート不要で設定が簡単。推奨方式。Lambdaカスタム統合（AWS）: VTL（Velocity Template Language）のマッピングテンプレートでリクエスト/レスポンスを変換。統合リクエストでLambdaへの入力を加工し、統合レスポンスでLambdaの出力をクライアント向けに整形。既存APIの形式に合わせる場合やAWSサービス直接統合で使用。設定は複雑だが柔軟性が高い。

</details>

### Q6: 認証方式の使い分け
**Q: API Gatewayの認証方式（IAM、Cognito、Lambda Authorizer）をそれぞれどのような場面で使い分けますか？**

<details><summary>模範解答</summary>

IAM認証: AWSサービス間通信、クロスアカウントアクセス、IAMユーザー/ロールによるアクセスに使用。SigV4署名が必要。Cognito Authorizer（REST API）: ユーザー認証が必要なWebアプリ/モバイルアプリ。ソーシャルログイン（Google, Facebook等）統合、ユーザープール管理が必要な場合。Lambda Authorizer: サードパーティのOAuth/SAMLトークン検証、カスタム認証ロジック、レガシー認証システムとの統合。TOKEN型はヘッダーのトークンのみ、REQUEST型はヘッダー+クエリ+パスパラメータで認可判断。結果はTTL（最大3600秒）でキャッシュ可能。

</details>

### Q7: リソースポリシー
**Q: 別アカウントのIAMロールがAPI Gatewayを呼び出せるようにするには、どのような設定が必要ですか？**

<details><summary>模範解答</summary>

クロスアカウントアクセスには2つの設定が必要。(1) API Gateway側: リソースポリシーで外部アカウントのIAMロールARNに対して`execute-api:Invoke`を許可。リソースARNでステージ/メソッド/リソースパスを制限可能。(2) 呼び出し側アカウント: IAMロールのポリシーで`execute-api:Invoke`を許可し、対象APIのARNをリソースとして指定。呼び出し時はSigV4署名が必要（IAM認証）。リソースポリシーはREST APIのみ対応。IPアドレス制限やVPCエンドポイント制限にも使用可能。同一アカウント内ではリソースポリシーまたはIAMポリシーのどちらかでAllowがあれば許可される。

</details>

### Q8: キャッシュ
**Q: API Gatewayキャッシュのセキュリティ上の注意点と、パーキーキャッシュについて説明してください。**

<details><summary>模範解答</summary>

セキュリティ注意点: デフォルトでは任意のクライアントが`Cache-Control: max-age=0`ヘッダーでキャッシュを無効化できる。`require-authorization-for-cache-control`を有効にし、IAM権限（`execute-api:InvalidateCache`）を持つクライアントのみにキャッシュ無効化を制限すべき。パーキーキャッシュ: クエリ文字列パラメータやHTTPヘッダーをキャッシュキーに含めることで、パラメータの値ごとに異なるレスポンスをキャッシュする。例: `?page=1`と`?page=2`で異なるキャッシュエントリ。キャッシュ容量は0.5GB〜237GB、TTLはデフォルト300秒（0〜3600秒）。REST APIのみ対応。暗号化オプションあり。

</details>

### Q9: CloudWatchメトリクス
**Q: API GatewayのCloudWatchメトリクスで、バックエンドの問題とAPI Gateway自体の問題をどう区別しますか？**

<details><summary>模範解答</summary>

LatencyとIntegrationLatencyの差分で区別する。Latency = API Gatewayがリクエストを受信してからレスポンスを返すまでの全体時間。IntegrationLatency = バックエンド（Lambda等）の処理時間のみ。差分（Latency - IntegrationLatency）がAPI Gatewayのオーバーヘッド。IntegrationLatencyが高い場合はバックエンドの問題（Lambda実行時間、DBクエリ等）。差分が大きい場合はAPI Gateway側の問題（認証処理、マッピング、スロットリング）。5XXError: 主にバックエンド障害（502 Bad Gateway, 504 Gateway Timeout）。4XXError: クライアントエラー（401未認証, 403アクセス拒否, 429スロットリング）。CacheHitCount/CacheMissCountでキャッシュ効率も監視。

</details>

### Q10: X-Rayトレーシング
**Q: API Gatewayの分散トレーシングをX-Rayで有効化する方法と、取得できる情報について説明してください。**

<details><summary>模範解答</summary>

有効化: ステージ設定でX-Rayトレーシングをオンにする（REST APIのみ）。Lambda関数側でもX-Rayを有効化し、X-Ray SDKを使用してDynamoDB等の下流サービス呼び出しをトレースする。取得情報: サービスマップ（API Gateway → Lambda → DynamoDB等の依存関係）、各セグメントのレイテンシ、エラー発生箇所、トレースID（X-Amzn-Trace-Id）。サンプリングレートを設定してコストとデータ量を制御可能。本番環境のパフォーマンスボトルネック特定、障害の根本原因分析、マイクロサービス間の依存関係可視化に有用。

</details>
